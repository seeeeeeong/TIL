### Array vs Linked List

- Array: 메모리 상에서 연속적으로 데이터를 저장하는 자료구조 입니다.
- Linked List: 메모리 상에서 불연속적으로 데이터를 저장하지만, 각 원소가 다음 원소의 메모리 주소를 저장하여 논리적 연속성을 유지하는 자료구조입니다.

#### 시간복잡도

| 연산        | Array            | Linked List      |
|-------------|------------------|------------------|
| **조회**    | O(1)             | O(n)             |
| **삽입/삭제**| O(n) (중간 위치) | O(1) (단순 연결) |


- 따라서 데이터의 크기를 알고있고, 조회를 자주 할 경우 Array가 유리합니다.
- 반면에, 데이터 크기가 불확실하고, 삽입/삭제를 자주 할 경우 Linked List가 유리합니다.

### 조회

- Array는 메모리 상에서 연속적으로 데이터를 저장하기 때문에 즉시 접근이 가능하며, O(1)의 시간이 소요됩니다.
- Linked List는 데이터가 메모리 상에서 불연속적으로 저장되므로 순차 접근만 가능합니다. 따라서 O(n)의 시간이 소요됩니다.

### 삽입/삭제

#### Array

- 맨 마지막 원소를 삽입/삭제할 경우 시간 복잡도는 O(1)입니다.
- 중간 위치에 삽입/삭제할 경우, 모든 원소를 한 칸씩 이동해야 하므로 O(n)의 시간이 소요됩니다.

#### LinkedList

- 삽입/삭제할 경우, 노드의 연결만 변경하면 되므로 시간복잡도는 O(1)입니다.
- 하지만, 삽입/삭제를 수행하려는 위치를 참기 위해 순차 탐색이 필요하므로, O(n)의 시간이 소요됩니다.


### memory

#### Array

- 배열은 선언 시 크기를 고정하여 메모리를 할당합니다.
- 데이터가 없는 공간도 메모리를 차지하므로 메모리 낭비가 발생할 수 있습니다.

#### LinkedList

- 크기를 자유롭게 조정할 수 있습니다.
- 필요한 만큼 메모리를 할당하기 때문에 메모리 낭비가 적습니다.

### Q. LinkedList가 Array보다 더 나은 상황

- 삽입과 삭제를 자주 해야 하는 경우, Linked List는 이론적으로 O(1)의 시간 복잡도를  가지지만,
실제로는 구현 방식이나 상황에 따라 O(n)의 시간복잡도를 가집니다.
- 하지만, 삽입/삭제 작업이 리스트의 특정 위치에서 반복적으로 이루어지는 경우에는 LinkedList를 적절히 구현하면
O(1)에 가까운 성능을 낼 수 있습니다.
- 데이터의 크기가 예측하기 어려운 겅우, 조회가 적고 삽입/삭제가 자주 수행되는 경우에 유리합니다.

### Q. Array가 LinkedList보다 더 나은 상황

- 데이터의 크기가 예측 가능한 경우, 조회가 자주 수행되는 경우에 유리합니다.
- 데이터의 크기가 예측 가능할 경우, 메모리를 적게 사용하기 위해 사용합니다.

### Q. 메모리 할당의 차이점

#### Array

- 컴파일 시 메모리가 할당됩니다. (Static Memory Allocation)
- 메모리는 Stack 영역에서 할당됩니다.

#### LinkedList

- 런타임 단계에서 새로운 Node가 추가될 때마다 메모리가 할당됩니다. (Dynamic Memory Allocation)
- 메모리는 Heap 영역에서 할당됩니다.